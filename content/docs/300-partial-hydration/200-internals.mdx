---
title: Internals
---

Key to the partial hydration is the `island` function, which is provided through a virtual module.
Depending on whether the build is performed in client or server mode, a different implementation is returned.

For client builds, the island function is a no-op, it returns the passed-in component verbatim.

For server builds, the function returns a higher order component that renders a fragment:
The original component followed by a script tag.

<Note>
  Most frameworks require an empty container element for rendering/hydrating an
  app. In this case Capri wraps the island inside an additional element with an
  `data-island-root` attribute and `display: contents`.
</Note>

That script tag is of type `application/json` and contains the component's initial props, serialized as JSON.
It also has a `data-island` attribute that identifies the component. The value is the moduleId of the
component's rollup chunk.

```html
<div data-island-root style="display: contents;">
  <div class="counter"><button>-</button>100<button>+</button></div>
  <script
    type="application/json"
    data-island="/src/Counter.island.tsx"
    data-key="Counter"
  >
    {
      "start": 100
    }
  </script>
</div>
```

In order to obtain this ID, the island module calls `import.meta.globEager()` to find all components that match
the configured glob pattern. It then compares the passed component to all found island
components (using a `===` check).

During the client-build, a hydration script is emitted that calls `import.meta.glob()` with the configured
pattern and instead of its eager counterpart, this yields a list of dynamic imports.

The rest is a matter of finding all hydration marker scripts in the DOM and hydrating their preceding siblings.
