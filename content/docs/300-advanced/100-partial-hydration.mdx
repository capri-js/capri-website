---
title: Partial hydration
---

One of Capri's core features is that it supports partial hydration, also known
as [islands architecture](https://jasonformat.com/islands-architecture/). This
means that Capri sites will by default ship zero KB of JavaScript to the
browser. If you need some interactivity on your pages, you can selectively
_hydrate_ these components.

## Creating islands

Create a regular React/Preact/SolidJS component and name it `*.island.(tsx|jsx)`.

Import the `island` function to create a higher order component like this:

```tsx
// Counter.island.tsx

import { useState } from "preact/hooks";
import { island } from "@capri-js/preact";

function Counter() {
  const [counter, setCounter] = useState(0);
  return (
    <div>
      {counter}
      <button onClick={() => setCounter((c) => c + 1)}>+</button>
    </div>
  );
}

export const CounterIsland = island(Counter);
```

<Note>
  The name of the export doesn't matter, you can also use a default export if
  you want.
</Note>

Use that wrapped component in your app to opt in to client-side hydration for that particular subtree:

```ts
// App.tsx

import { CounterIsland } from "./Counter.island";

export function App() {
  return (
    <main>
      <h1>
        Welcome to <i>Capri</i>
      </h1>
      <div>This page is static, but contains some dynamic parts.</div>
      <div>
        Here is a simple counter: <CounterIsland />
      </div>
      <div>
        And here is another one, independent of the one above:
        <CounterIsland start={100} />
      </div>
    </main>
  );
}
```

## Static child content

Child components that are passed from a parent on to an island are only rendered on the
server. Upon hydration, the children are replaced by a single component that returns the
static HTML as it was initially rendered. Therefore, the `children` property won't be included
in the island marker script, where all other initial props are serialized.

## Lagoons

Islands can again have static child components. We call them lagoons. In order to create a
lagoon, you have to provide a factory function that returns a dynamic import. This way
the code won't show up in the client bundle.

```ts
// Menu.island.tsx

import { island, lagoon } from "@capri-js/react";
import { useState } from "react";

const MenuItems = lagoon(() => import("./MenuItems.jsx"));

function Menu() {
  const [expanded, setExpanded] = useState(false);
  return (
    <div data-expanded={expanded}>
      <button onClick={() => setExpanded(!expanded)}>Menu</button>
      <MenuItems />
    </div>
  );
}

export const MenuIsland = island(Menu);
```

And this is what the MenuItems component looks like:

```ts
// MenuItems.tsx

export default function MenuItems() {
  console.log("Rendering MenuItems. This will only happen during build.");
  return (
    <ul>
      <li>
        <a href="/one">Item one</a>
      </li>
      <li>
        <a href="/two">Item two</a>
      </li>
      <li>
        <a href="/three">Item three</a>
      </li>
    </ul>
  );
}
```

<Note>
  Since we use a dynamic import, `MenuItems` must be the default export.
</Note>

## Island options

### `media: string`

Only hydrate the component when the given media query matches. In the following example
the hydration of the component will be deferred until the viewport width gets below 700 pixels:

```ts
// BurgerMenu.island.tsx

function BurgerMenu() {
  // ...
}

export const BurgerMenuIsland = island(BurgerMenu, {
  media: "(max-width: 700px)",
});
```

<Note title="Stay tuned">
  We are planing to add more options, for example to only hydrate islands that
  are within the viewport.
</Note>
